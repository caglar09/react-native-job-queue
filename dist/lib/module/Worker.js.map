{"version":3,"names":["AppState","CANCEL","Worker","constructor","name","executer","options","_defineProperty","onStart","job","onSuccess","onFailure","error","onCompletion","concurrency","executionCount","isBusy","availableExecuters","execute","rawJob","timeout","payload","JSON","parse","currentState","executeWithTimeout","id","cancel","promise","Promise","resolve","reject","timeoutPromise","setTimeout","Error","executerPromise","race","triggerSuccess","triggerFailure","triggerCompletion","decreaseExecutionCount"],"sources":["Worker.ts"],"sourcesContent":["import { AppState } from 'react-native';\nimport { Job, RawJob } from './models/Job';\n\nexport const CANCEL = 'rn_job_queue_cancel';\n\nexport interface WorkerOptions<P extends object> {\n    onStart?: (job: Job<P>) => void;\n    onSuccess?: (job: Job<P>) => void;\n    onFailure?: (job: Job<P>, error: Error) => void;\n    onCompletion?: (job: Job<P>) => void;\n    concurrency?: number;\n}\n\nexport interface CancellablePromise<T> extends Promise<T> {\n    rn_job_queue_cancel?: (error?: Error) => void;\n}\n/**\n * @typeparam P specifies the Type of the Job-Payload.\n */\nexport class Worker<P extends object> {\n    public readonly name: string;\n    public readonly concurrency: number;\n\n    private executionCount: number;\n    private executer: (payload: P, id: string) => CancellablePromise<any>;\n\n    private onStart: (job: Job<P>) => void;\n    private onSuccess: (job: Job<P>) => void;\n    private onFailure: (job: Job<P>, error: Error) => void;\n    private onCompletion: (job: Job<P>) => void;\n\n    /**\n     *\n     * @typeparam P specifies the type of the job-payload.\n     * @param name of worker\n     * @param executer function to run jobs\n     * @param options to configure worker\n     */\n    constructor(name: string, executer: (payload: P, id: string) => Promise<any>, options: WorkerOptions<P> = {}) {\n        const {\n            onStart = (job: Job<P>) => { },\n            onSuccess = (job: Job<P>) => { },\n            onFailure = (job: Job<P>, error: Error) => { },\n            onCompletion = (job: Job<P>) => { },\n            concurrency = 5,\n        } = options;\n\n        this.name = name;\n        this.concurrency = concurrency;\n\n        this.executionCount = 0;\n        this.executer = executer;\n\n        this.onStart = onStart;\n        this.onSuccess = onSuccess;\n        this.onFailure = onFailure;\n        this.onCompletion = onCompletion;\n    }\n\n    /**\n     * @returns true if worker runs max concurrent amout of jobs\n     */\n    get isBusy() {\n        return this.executionCount === this.concurrency;\n    }\n    /**\n     * @returns amount of available Executers for current worker\n     */\n    get availableExecuters() {\n        return this.concurrency - this.executionCount;\n    }\n    /**\n     * This method should not be invoked manually and is used by the queue to execute jobs\n     * @param job to be executed\n     */\n    execute(rawJob: RawJob) {\n        const { timeout } = rawJob;\n        const payload: P = JSON.parse(rawJob.payload);\n        const job = { ...rawJob, ...{ payload } };\n        this.executionCount++;\n        this.onStart(job);\n        if (timeout > 0 && AppState.currentState === 'active') {\n            return this.executeWithTimeout(job, timeout);\n        } else {\n            return this.executer(payload, job.id);\n        }\n    }\n    private executeWithTimeout(job: Job<P>, timeout: number) {\n        let cancel;\n        const promise: CancellablePromise<any> = new Promise(async (resolve, reject) => {\n            const timeoutPromise = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    reject(new Error(`Job ${job.id} timed out`));\n                }, timeout);\n            });\n            const executerPromise = this.executer(job.payload, job.id);\n            if (executerPromise) {\n                cancel = executerPromise[CANCEL];\n                try {\n                    await Promise.race([timeoutPromise, executerPromise]);\n                    resolve(true);\n                } catch (error) {\n                    // cancel task if has cancel method\n                    if (executerPromise[CANCEL] && typeof executerPromise[CANCEL] === 'function') {\n                        executerPromise[CANCEL]!();\n                    }\n                    reject(error);\n                }\n            }\n        });\n        promise[CANCEL] = cancel;\n        return promise;\n    }\n\n    triggerSuccess(job: Job<P>) {\n        this.onSuccess(job);\n    }\n    triggerFailure(job: Job<P>, error: Error) {\n        this.onFailure(job, error);\n    }\n    triggerCompletion(job: Job<P>) {\n        this.onCompletion(job);\n    }\n    decreaseExecutionCount() {\n        this.executionCount--;\n    }\n}\n"],"mappings":"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","ignoreList":[]}